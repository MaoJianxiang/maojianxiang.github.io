<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="致力于苹果移动应用的开发">
<meta property="og:type" content="website">
<meta property="og:title" content="小毛的博客">
<meta property="og:url" content="https://maojianxiang.github.io/index.html">
<meta property="og:site_name" content="小毛的博客">
<meta property="og:description" content="致力于苹果移动应用的开发">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小毛的博客">
<meta name="twitter:description" content="致力于苹果移动应用的开发">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://maojianxiang.github.io/"/>





  <title> 小毛的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小毛的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">追求卓越，精益求精</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2018/06/04/面试总结-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/04/面试总结-一/" itemprop="url">
                  面试总结(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-04T17:03:15+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview/" itemprop="url" rel="index">
                    <span itemprop="name">Interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很早就想把自己遇到的面试的相关技术问题进行记录和总结一下，但一直因为这一年的时间上班都比较忙，就没有整理。最近为了招人，公司出了套面试题，然后分部也让我出一套，我最后就去网上找了一些，最后结合总部的，弄了一套。感觉也没什么特别的难度，现在正好偶尔有些时间就把它整理一下。</p>
<h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><p><strong>1. 请说明并比较以下关键词：strong, weak, assign, copy？</strong></p>
<p>  <em>（ARC跟MRC，strong代替retain. weak代替assign)<br>  strong :  强引用, 引用计数会加1,只要某一对象被一个strong指向，该对象就不会被销毁。<br>  weak：  弱引用，当指身的对象被释放后自动置为nil<br>  assign的作用：简单赋值，不改变引用计数，对基础数据类型 （例如NSInteger，CGFloat）和C数据类型（int, float, double, char, 等） 适用简单数据类型。若指身对象，则对象被释放后不能自动为空<br>  copy的作用：建立一个索引计数为1 的新对象，然后释放旧对象。</em></p>
<p><strong>2. 属性关键字readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用?</strong></p>
<ol>
<li>readwrite 是可读可写特性;需要生成getter方法和setter方法时; </li>
<li>readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变; </li>
<li>assign 是赋值特性，setter方法将传入参数赋值给实例变量;仅设置变量时; </li>
<li>retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1; </li>
<li>copy 表示赋值特性，setter方法将传入对象复制一份;需要完全一份新的变量时; </li>
<li><p>nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic;atomic:设置成员变量的@property属性时，默认为atomic，提供多线程安全。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。加了atomic，setter函数会变成下面这样:</p>
<p>   if (property != newValue) { </p>
<pre><code>[property release]; 
property = [newValue retain]; 
} 
</code></pre><p>nonatomic:禁止多线程，变量保护，提高性能。</p>
</li>
</ol>
<p><strong>3. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么?与Extension(延展)的主要区别?</strong></p>
<p> <em>Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别(分类, 类目)，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。通常情况下Category只可以添加方法, 而Extension可以添加方法和属性(都是私有的);但是Category可以通过runtime.h中objc_getAssociatedObject / objc_setAssociatedObject来访问和生成关联对象。通过这种方法来模拟生成属性。(需要重写属性的set和get方法)</em></p>
<p><strong>4. 面的代码有什么问题？如果有问题怎样修改？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *target;</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10000000000; i++) &#123;</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        self.target = [NSString stringWithFormat:@&quot;ksddkjalkjd%d&quot;,i];</span><br><span class="line">       &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><em>直接运行会崩溃 EXC_BAD_ACCESS(坏内存地址，对象被释放)， 属性target的setter方法有关：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> -(void)setTarget:(NSString *)target &#123;  </span><br><span class="line"> [target retain];//先保留新值</span><br><span class="line"> [_target release];//再释放旧值</span><br><span class="line"> _target = target;//再进行赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>因为self.target 重新赋值是个多线程任务(并行队列+异步),所以存在着当其中一个线释放了同一个对象时，另一个线程就去给訪对象赋值。也就是多个线程操作同一对象造成的内存释放空的崩溃。这属于线程安全问题，可以用原子性atomic属性关键字进行加锁。如果只是解决崩溃问题的话，用atomic和strong加锁，或者用weak和 nonatomic都可以解决这个问题。但是另外还存在3个问题：</em></p>
<ol>
<li>你创建这么大的循环数值干嘛，专门消耗运行，阻塞运算卡线程吗</li>
<li>用weak和atomic你重新赋值代码运算，有大部分运算等同于没有执行，</li>
<li>这个结果也不可控，结果得到一个随机值</li>
</ol>
<p><strong>5. 中有什么bug？如果有请指出怎样修改？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  UILabel *alertLabel=[[UILabel alloc] initWithFrame:CGRectMake(100,100,100,100)];</span><br><span class="line">  alertLabel.text = @&quot;Wait 3 seconds...&quot;;</span><br><span class="line">  [self.view addSubview:alertLabel];</span><br><span class="line">  NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">  [backgroundQueue addOperationWithBlock:^&#123;</span><br><span class="line">    [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:4];</span><br><span class="line">    alertLabel.text = @&quot;begin！&quot;;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p> <em>页面上的label的修改，需要在主线程中实现，现在在子线程中，运行会崩，将二次赋值的代码修改到主线程即可</em></p>
<p><strong>6. Objective-C如何进行内存管理的,说说你的看法和解决方法?OC有垃圾回收机智吗?iOS有垃圾回收机智吗?</strong></p>
<p> <em>Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</em></p>
<ol>
<li><p>(Garbage Collection)(垃圾回收)自动内存计数：这种方式和java类似，在你的程序的执行过程中。始终有一个高人在背后准确地帮你收拾垃圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以iPhone不支持这个功能。</p>
<p> <em>解决: 通过alloc – initial方式创建的, 创建后引用计数+1, 此后每retain一次引用计数+1, 那么在程序中做相应次数的release就好了.</em></p>
</li>
<li><p>(Reference Counted)手动内存计数：就是说，从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为0的时候，那么就是释放这段内存的时候。比如说，当在程序A里面一段内存被成功申请完成之后，那么这个计数器就从0变成1(我们把这个过程叫做alloc)，然后程序B也需要使用这个内存，那么计数器就从1变成了2(我们把这个过程叫做retain)。紧接着程序A不再需要这段内存了，那么程序A就把这个计数器减1(我们把这个过程叫做release);程序B也不再需要这段内存的时候，那么也把计数器减1(这个过程还是release)。当系统(也就是Foundation)发现这个计数器变成了0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做dealloc)。顺便提一句，如果没有Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。*</p>
<p><em>解决:一般是由类的静态方法创建的, 函数名中不会出现alloc或init字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的局部变量. 当然也可以通过retain延长对象的生存期.</em></p>
</li>
<li><p>(AutoRealeasePool)内存池：可以通过创建和释放内存池控制内存申请和回收的时机.</p>
<p><em>解决:是由autorelease加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像main函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.</em></p>
</li>
</ol>
<p><strong>7. 我们说的oc是动态运行时runtime语言是什么意思?</strong></p>
<p><em>主要是将数据类型的确定由编译时，推迟到了运行时。</em></p>
<p><em>这个问题其实浅涉及到两个概念，运行时和多态。</em></p>
<p><em>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都拥有一个相同的方法-eat;那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器).因此也可以说，运行时机制是多态的基础.</em></p>
<p><strong>8. 简述一下block和使用delegate 各有什么区别？</strong><br><em>代理（delegate）需要写协议,代理方法和设置代理对象 block需要定义block, 实现block,调用block</em></p>
<p><em>delegate:</em></p>
<ol>
<li>“一对一”，对同一个协议，一个对象只能设置一个代理delegate，所以单例对象就不能用代理;</li>
<li>代理更注重过程信息的传输：比如发起一个网络请求，可能想要知道此时请求是否已经开始、是否收到了数据、数据是否已经接受完成、数据接收失败</li>
</ol>
<p><em>block：</em></p>
<ol>
<li>写法更简练，不需要写protocol、函数等等</li>
<li>block注重结果的传输：比如对于一个事件，只想知道成功或者失败，并不需要知道进行了多少或者额外的一些信息</li>
<li>block需要注意防止循环引用：(ARC中，Block中如果引用了__strong修饰符的自动变量，则相当于Block对该变量的引用计数+1, 在ARC下，由于__block抓取的变量一样会被Block retain，所以必须用弱引用才可以解决循环引用问题，iOS 5之后可以直接使用__weak，之前则只能使用__unsafe<em>unretained了，\</em>_unsafe_unretained缺点是指针释放后自己不会置空)*</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ARC:</span><br><span class="line">__weak typeof(self) weakSelf = self;  </span><br><span class="line">  [yourBlock:^(NSArray *repeatedArray, NSArray *incompleteArray) &#123;</span><br><span class="line">  [weakSelf doSomething];</span><br><span class="line"> &#125;];</span><br><span class="line">  // 非ARC: </span><br><span class="line">__block typeof(self) weakSelf = self;</span><br><span class="line"> [yourBlock:^(NSArray *repeatedArray, NSArray *incompleteArray) &#123;</span><br><span class="line">  [weakSelf doSomething];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p> <strong>9. 简述一下你对进程和线程的认识和了解？</strong></p>
<p><em>关系：</em></p>
<ol>
<li>数量角度：一个线程只能属于一个进程，而一个进程可以包含多个线程，但至少包含一个线程。</li>
<li>资源角度：资源分配给进程，同一个进程中的线程共享该进程的所有资源。</li>
<li>线程是进程内的一个可执行单元，也是进程内的可调度实体。</li>
<li>真正运行在处理机上的是线程.</li>
<li>线程在执行过程中需要协作同步。不同进行的线程间要利用消息通信的办法实现同步。</li>
</ol>
<p><em>区别：</em></p>
<ol>
<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于所在进程的资源。</li>
<li>调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位（系统根据进程分配资源）。</li>
<li>并发性：不仅进程间可以并发执行，同一个进程中的多个线程之间也可以并发执行。</li>
<li>系统开销：创建或者销毁进程的开销比较大，因为进程在分配和撤销时需要创建和回收资源。</li>
<li>健壮性：进程有自己独立的系统空间，线程没有，进程的撤销对其他进程没有影响，而线程的撤销将可能使所在进程死掉。所以，多进程的程序比多线程的程序健壮。但在进程切换时耗费的资源比较大，效率差。</li>
</ol>
<p><strong>10. ios 平台怎么做数据的持久化?coredata 和sqlite有无必然联系？coredata是一个关系型数据库吗？</strong></p>
<p><em>iOS 中可以有四种持久化数据的方式：属性列表(plist)、对象归档、 SQLite3 和 Core Data； core data 可以使你以图形界面的方式快速的定义 app 的数据模型，同时在你的代码中容易获取到它。 coredata 提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在 app 中继续创建新的任务。在使用 core data 的时候，你不用安装额外的数据库系统，因为 core data 使用内置的 sqlite 数据库。 core data 将你 app 的模型层放入到一组定义在内存中的数据对象。 coredata 会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当 core data 在对你 app 数据的改变进行保存的时候， core data 会把这些数据归档，并永久性保存。 mac os x 中sqlite 库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用， sqlite 是一个轻量级的嵌入式 sql 数据库编程。与 core data 框架不同的是， sqlite 是使用程序式的， sql 的主要的 API 来直接操作数据表。 Core Data 不是一个关系型数据库，也不是关系型数据库管理系统 (RDBMS) 。虽然 Core Dta 支持SQLite 作为一种存储类型，但它不能使用任意的 SQLite 数据库。 Core Data 在使用的过程种自己创建这个数据库。 Core Data 支持对一、对多的关系。</em></p>
<p><strong>11. Swift中，类（class）和结构体（struct）有什么区别？</strong></p>
<p><em>Swift中，类是引用类型，结构体是值类型。值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个”指向”。所以他们两者之间的区别就是两个类型的区别。</em></p>
<p><em>class有这几个功能struct没有的：</em></p>
<ol>
<li>class可以继承，这样子类可以使用父类的特性和方法</li>
<li>类型转换可以在runtime的时候检查和解释一个实例的类型</li>
<li>可以用deinit来释放资源</li>
<li>一个类可以被多次引用</li>
</ol>
<p>struct也有这样几个优势：</p>
<ol>
<li>结构较小，适用于复制操作，相比于一个class的实例被多次引用更加安全</li>
<li>无须担心内存memory leak或者多线程冲突问题</li>
</ol>
<p><strong>12. 比较Swift和Objective-C中的初始化方法（init）有什么异同?</strong></p>
<p> <em>总的来说，Swift中的初始化方法更加严格和准确</em></p>
<p> <em>Objective-C中，初始化方法无须保证所有成员变量都完成初始化；编译器对属性设置并无警告，但是实际操作中会出现初始化不完全的问题；初始化方法与普通方法并无实际差别，可以多次调用。</em></p>
<p><em>swift中，初始化方法必须保证所有optional的成员变量都完成初始化。同时新增convenience和required两个修饰初始化方法的关键词。convenience只是提供一种方便的初始化方法，必须通过调用同一个类中designated初始化方法来完成。required是强制子类重写父类中所修饰的初始化方法。</em></p>
<p><strong>13. 请说明并比较以下关键词：Open, Public, Internal, File-private, Private?</strong></p>
<p><em>Swift 有五个级别的访问控制权限，从高到底依次为比如 Open, Public, Internal, File-private, Private</em></p>
<p><em>他们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如一个 private 的 class 中不能含有 public 的 String。反之，低级别的变量却可以定义在高级别的变量中。比如 public 的 class 中可以含有 private 的 Int。</em></p>
<ol>
<li>Open 具备最高的访问权限。其修饰的类和方法可以在任意 Module 中被访问和重写；它是 Swift 3 中新添加的访问权限。</li>
<li>Public 的权限仅次于 Open。与 Open 唯一的区别在于它修饰的对象可以在任意 Module 中被访问，但不能重写。</li>
<li>Internal 是默认的权限。它表示只能在当前定义的 Module 中访问和重写，它可以被一个 Module 中的多个文件访问，但不可以被其他的 Module 中被访问。</li>
<li>File-private 也是 Swift 3 新添加的权限。其被修饰的对象只能在当前文件中被使用。例如它可以被一个文件中的 class，extension，struct 共同使用。</li>
<li>Private 是最低的访问权限。它的对象只能在定义的作用域内使用。离开了这个作用域，即使是同一个文件中的其他作用域，也无法访问。</li>
</ol>
<p><strong>14. Swift 到底是面向对象还是函数式的编程语言？</strong></p>
<p><em>Swift 既是面向对象的，又是函数式的编程语言。</em> <br><em>说 Swift 是 Object-oriented，是因为 Swift 支持类的封装、继承、和多态，从这点上来看与 Java 这类纯面向对象的语言几乎毫无差别。</em></p>
<p><em>说 Swift 是函数式编程语言，是因为 Swift 支持 map, reduce, filter, flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。</em></p>
<p><strong>15. 泛型是什么？用来解决什么问题？</strong></p>
<p><em>泛型可以使某一个类型的算法能够更安全的工作。在Swift中泛型可以用在函数和数据类型上，如类，结构体和枚举类型。</em></p>
<p><em>泛型还能解决代码重复的问题。普遍现象是当你已经有一个带参数的方法，但你又不得不再重新写一遍有着类似类型的方法。</em></p>
<p><strong>16. 在Swift和Objective-C的混编项目中，如何在Swift文件中调用Objective-C文件中已经定义的方法？如何在Objective-C文件中调用Swift文件中定义的方法？反之又如何？</strong></p>
<p>   Swift调用OC： </p>
<p>   <em>创建桥接头文件 xxxx Bridging-Header.h,在头文件中导入OC类的头文件.h.在swift中就可以使用了</em></p>
<p>   OC调用Swift:  </p>
<ol>
<li><p>配置命名空间   在TARGETS -&gt; Build Setting中：<br>Asset-&gt;Enable Asset Packs In Product Bundle中设置为NO</p>
<p>Packaging -&gt;  Defines module 设置为YES</p>
<p>Packaging -&gt; Product Module Name 设置swift的命名空间名字（namespace）</p>
<ol>
<li>在需要使用swift的OC类中导入头文件使用#import “ namespace -Swift.h”,就可以使用swift的类了</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2018/05/24/Swift-可选项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/24/Swift-可选项/" itemprop="url">
                  Swift-可选项
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T16:46:05+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift中新增加了可选项，用问号’?’来表示，那我们如何运用和理解了？</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>可选项的主要目的就是为了解决‘有’和‘无’的问题。表示变量可以为nil,或者一个值。而且它只明定义，没有分配空间和初始化。定义属性只需要在后面加上？如：var label : UILabel?</p>
<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>Swift是特别在意安全性问题的，对可选项可以进行强行解包和可选解包。</p>
<h4 id="强行解包"><a href="#强行解包" class="headerlink" title="强行解包"></a>强行解包</h4><p>用问号’!’来表示,强行解包后的值主要是为了参与计算，但是强行解包存在着风险，当为nil时，程序运行会崩溃，所以需要判断好是否为nil。</p>
<p>可以用 guard let / if let 来处理解包问题，简化代码。</p>
<h4 id="可选解包"><a href="#可选解包" class="headerlink" title="可选解包"></a>可选解包</h4><p>用问号’?’来表示,不能参与计算。但可以用来调用方法，它的意思是如果对象存在不为空时就调用对象的方法，如果对象为nil，就什么也不用做，程序也不会崩溃。</p>
<h4 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h4><h4 id="as"><a href="#as" class="headerlink" title="as?"></a>as?</h4><ul>
<li>用as?进行转化的话，得到的结果是可选的</li>
<li>用guard let / if let时 一定要用 as? 来修饰</li>
</ul>
<h4 id="as-1"><a href="#as-1" class="headerlink" title="as!"></a>as!</h4><p>前面的结果一定要有正确值，不然会崩溃，在使用时就需要程序员考虑值的安全性。</p>
<h4 id="as-2"><a href="#as-2" class="headerlink" title="as"></a>as</h4><p>OC和Swift的类型转化,底层做了结构体和OC的对象桥接</p>
<pre><code>NSSString -&gt; String
NSArray -&gt; []
NSDictionary -&gt; [string : Any]
</code></pre><p>将父类转化成子类，或者将子类转化成父类时候需要类型转化，因为要调用子类或者父类的方法。</p>
<p>Swift调用OC的类或者方法时。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2018/05/22/两位数的乘法快捷算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/22/两位数的乘法快捷算法/" itemprop="url">
                  两位数的乘法快捷算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-22T10:41:52+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天看到抖音上有人关于头相尾的快捷计算方法，觉得确实有趣。不过，我从高中时也是无意间从一本书上看到的简便计算方法，从那时开始我就一直在用，到现我都不知道这种计算有没有名字。确实要比按照常规计算要容易一些，而且会快一些。 <br>但总的来说，万变不离其宗，不管是怎么样的计算方法，它都是遵从计算的基本原理，然后从中找出的规律来总结出来的。</p>
<hr>
<h3 id="通用的两位数计算法"><a href="#通用的两位数计算法" class="headerlink" title="通用的两位数计算法"></a>通用的两位数计算法</h3><h4 id="如图如示"><a href="#如图如示" class="headerlink" title="如图如示"></a>如图如示</h4><p> <img src="/2018/05/22/两位数的乘法快捷算法/100.png" alt="1"></p>
<h4 id="计算过程-数a-x-数b"><a href="#计算过程-数a-x-数b" class="headerlink" title="计算过程  (数a x 数b)"></a>计算过程  (数a x 数b)</h4><pre><code>1. 个位相乘： a个位数 x b个位数 = 结果1，结果1以个位为基数
2. 十位相乘： a十位数 x b十位数 = 结果2，结果2以百位为基数
3. 交叉相乘： a十位数 x b个位数 + b十位数 X a个位数 = 结果3，结果3以十位为基数
4. 总和结果： 结果1 + 结果2 + 结果3 = 总结果
</code></pre><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><pre><code>* 其实只要细细一想，它跟基本的计算方法是一脉相承的
* 可以减少进位数在常规计算中造成的错误
* 降低了一些常规计算中的思维处理细节,仅仅只有第3步会在数大的时候
* 通用于2位数的相乘计算
</code></pre><p> 总之，它确实从一定的方面简化了计算难度，减少了常规计算中容易造成的错误。</p>
<h3 id="头同尾补"><a href="#头同尾补" class="headerlink" title="头同尾补"></a>头同尾补</h3><p>  头同就是十位数都一样的，尾补就是个位两数之和刚好是10.所以了，这种计算就是要先判断条件是否满足。<br>   <img src="/2018/05/22/两位数的乘法快捷算法/200.png" alt="2"></p>
<ul>
<li>(相同的十位数 + 1）x 相同的十位数 = 结果1，结果1以百位为基数</li>
<li>两尾数相乘  =  结果2，结果2以个位为基数</li>
<li>总和结果  =  结果1 + 结果2 </li>
</ul>
<h3 id="a乘数互补，b乘数数字相同"><a href="#a乘数互补，b乘数数字相同" class="headerlink" title="a乘数互补，b乘数数字相同"></a>a乘数互补，b乘数数字相同</h3><p>   即一个乘数的十位数和个位数互补，另一个乘数的十位数跟个位数相同。<br>   <img src="/2018/05/22/两位数的乘法快捷算法/300.png" alt="3"></p>
<ul>
<li>(a的十位数 + 1）x b的十位数 = 结果1，结果1以百位为基数</li>
<li>a的个位数 x b的个位数 = 结果2，结果2以个位为基数</li>
<li>总和结果  =  结果1 + 结果2</li>
</ul>
<h3 id="其他几种"><a href="#其他几种" class="headerlink" title="其他几种"></a>其他几种</h3><h4 id="十几乘十几"><a href="#十几乘十几" class="headerlink" title="十几乘十几"></a>十几乘十几</h4><p>   <img src="/2018/05/22/两位数的乘法快捷算法/400.png" alt="4"></p>
<ul>
<li>两数十位数相乘 = 结果1，结果1以百位为基数</li>
<li>两数个位数相加 = 结果2，结果2以十位为基数</li>
<li>两数个位数相乘 = 结果3，结果3以个位为基数</li>
<li>总和结果  =  结果1 + 结果2 + 结果3</li>
</ul>
<h4 id="几十一乘几十一"><a href="#几十一乘几十一" class="headerlink" title="几十一乘几十一"></a>几十一乘几十一</h4><p>  <img src="/2018/05/22/两位数的乘法快捷算法/500.png" alt="5"></p>
<ul>
<li>两数十位数相乘 = 结果1，结果1以百位为基数</li>
<li>两数十位数相加 = 结果2，结果2以十位为基数</li>
<li>两数个位数相乘 = 结果3，结果3以个位为基数</li>
<li>总和结果  =  结果1 + 结果2 + 结果3</li>
</ul>
<h4 id="任意数-x-11"><a href="#任意数-x-11" class="headerlink" title="任意数 x 11"></a>任意数 x 11</h4><p>  <img src="/2018/05/22/两位数的乘法快捷算法/600.png" alt="6"><br>  任意数逻位相加 </p>
<p>  可扩展到 乘数为11 ，111，1111……，其中只是逻的数的个数不同。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  总之，除此之外还有一些方法，但是相乘的实质都是一样的，这些方法只是在特殊情况下可以运用这些简便地运算而已。一般情况下能运用前两种方法就已经够用了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/07/04/Swift中的高阶函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/Swift中的高阶函数/" itemprop="url">
                  Swift中的高阶函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-04T17:10:46+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>   Swift的标准数组支持三个高阶函数：map，filter和reduce,以及map的扩展flatMap。Objective-C的NSArray没有实现这些方法，但是开源社区弥补了这个不足。</p>
<p>极大地体现了Swift的高大功能和优点。</p>
<hr>
<h3 id="了解闭包"><a href="#了解闭包" class="headerlink" title="了解闭包"></a>了解闭包</h3><ul>
<li><p>阐述</p>
<p> Swift一大特性便是使用简洁的头等函数（闭包）语法代替了复杂的blocks语法。头等函数-即可将函数当作参数传递给其他的函数，或从其他的函数里返回出值，并且可以将他们设定为变量，或者将他们存储在数据结构中。</p>
<p>闭包的形式： （(参数) -&gt; 返回值)</p>
</li>
<li><p>我们先写一个求立方的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //MARK: -- 立方</span><br><span class="line">func cube(_ a: Float) -&gt; Float&#123;</span><br><span class="line">    return a*a*a</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两数进行f函数运算后的平均值的函数 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func averageOfFunction(_ a: Float ,_ b: Float ,_ f: ((Float) -&gt; Float)) -&gt; Float&#123;   </span><br><span class="line">  return (f(a) + f(b))/2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>进行调用，简化闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//直接传参数和函数名</span><br><span class="line">let sum1 =   averageOfFunction(2, 3, cube)</span><br><span class="line"></span><br><span class="line">//直接把闭包做为它的函数方法参数</span><br><span class="line">let sum2 =   averageOfFunction(2, 3, &#123;(x : Float) -&gt;  Float in x*x*x &#125;)</span><br><span class="line"></span><br><span class="line">//隐式推断输入值为一个Float</span><br><span class="line">let sum3 =   averageOfFunction(2, 3, &#123;x -&gt; Float in x*x*x &#125;)</span><br><span class="line"></span><br><span class="line">//把retuen一起忽略</span><br><span class="line">let sum4 =   averageOfFunction(2, 3, &#123;x in x*x*x &#125;)</span><br><span class="line"></span><br><span class="line">//使用默认参数名，最简化地写法</span><br><span class="line">let sum5 =   averageOfFunction(2, 3, &#123; $0*$0*$0 &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>默认参数名补充</p>
<p> 我们还可以忽略指定参数名，使用默认参数名$0（如果函数接收多个参数，使用$K作为第K-1个参数，如$0，$1，$2……）</p>
<p> 在高阶函数中也会根据闭包的的简化来进行简化代码。</p>
</li>
</ul>
<hr>
<h3 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h3><ul>
<li><p>map需求</p>
<p>map用于将每个数组元素通过某个方法进行转换。<br>我们用一个Int类型数组，想把每个数后面添加一个字符“元”，把数组转成字符串数组 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let moneyArray = [12,34,8,17,91,2,82]</span><br><span class="line">var stringArray : [String] = []//结果数组</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>一般的思维</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for money in moneyArray &#123;</span><br><span class="line">   stringArray.append(&quot;\(money)元&quot;)</span><br><span class="line">    &#125;    </span><br><span class="line">print(stringArray)</span><br></pre></td></tr></table></figure>
</li>
<li><p>map的函数介绍</p>
<p>public func map<t>(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]</t></p>
<p>以一个命名函数transform作为参数，transform负责把元素Element转成类型T并返回一个类型T的数组。</p>
<p>在我们的事例中，T为Int，T为String，作为转换函数传给map的是一个把Int转成String</p>
</li>
<li><p>map的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stringArray = moneyArray.map(&#123; (a: Int) -&gt; String in</span><br><span class="line">  return &quot;\(a)元&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//MARK: -- 可以直接把代码换成一个简化的简约闭包</span><br><span class="line"> stringArray = moneyArray.map(&#123;money in &quot;\(money)元&quot;&#125;)</span><br><span class="line"> print(stringArray)</span><br><span class="line"></span><br><span class="line">//MARK: -- 最简约的写法，采用默认参数</span><br><span class="line">stringArray = moneyArray.map(&#123;&quot;\($0)元&quot;&#125;)</span><br><span class="line">print(stringArray)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul>
<li><p>filter需求</p>
<p>filter用于选择数组元素中满足某种条件的元素。使用上面的例子，筛选出大于20的元素，结果应该是[34,91,82]</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var  filterArray : [Int] =[]//结果数组</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>一般的思维</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> for money in moneyArray &#123;</span><br><span class="line">       if money &gt; 20&#123;</span><br><span class="line">            filterArray.append(money)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">print(filterArray)</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter的函数介绍</p>
<p> public func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; [Element]</p>
<p> 以一个命名函数isIncluded作为参数,isIncluded返回true或者false,对原数组元素Element调用isIncluded时，只有返回true的元素会通过筛选，从而放入返回数组 [Element]中</p>
</li>
<li><p>filter的方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> filterArray = moneyArray.filter(&#123; (a: Int) -&gt; Bool in</span><br><span class="line">   return a &gt; 20</span><br><span class="line">&#125;)       </span><br><span class="line"> print(filterArray)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> //MARK: — 一个简化的简约闭包</span><br><span class="line">filterArray = moneyArray.filter(&#123;money in money &gt; 30&#125;)       </span><br><span class="line">print(filterArray)</span><br><span class="line"></span><br><span class="line"> //MARK: -- 最简约的写法，采用默认参数</span><br><span class="line">filterArray = moneyArray.filter(&#123;$0 &gt; 30&#125;)       </span><br><span class="line">print(filterArray)</span><br></pre></td></tr></table></figure>
</code></pre><hr>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><ul>
<li><p>reduce需求</p>
<p> reduce方法把数组元素组合计算为一个值。我们使用上面例子计算数组元素的和，结果应该为246(12+34+8+17+91+2+82) 以及: 828102912(12 X 34 X 8 X 17 X 91 X 2 X 82)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var  filterArray : [Int] =[]//结果数组</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般的思维</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//MARK: — 求和</span><br><span class="line">var sum = 0</span><br><span class="line">for money in moneyArray &#123;</span><br><span class="line">        sum += money</span><br><span class="line">    &#125;</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">//MARK: — 求乘积</span><br><span class="line">  var product = 1  </span><br><span class="line">  for money in moneyArray &#123;</span><br><span class="line">        product = product * money</span><br><span class="line">    &#125;  </span><br><span class="line"> print(product)</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce的函数介绍</p>
<p>Reduce便可用于快速完成这类操作，通过指定一个初始值和一个组合元素的方法.</p>
<p>public func reduce<result>(<em> initialResult: Result, </em> nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result</result></p>
<p>接收两个参数，一个为initialResult的命名参数，类型跟Result一样的的初始值参数，另一个是命名函数nextPartialResult，把Result类型和数组元素Element进行运算，得到一个Result，逐个运行算成后得到最终的Result，将其返回。</p>
</li>
<li><p>reduce的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//MARK: --一个简化的简约闭包 </span><br><span class="line">let sum = moneyArray.reduce(0) &#123; (a : Int, b : Int) -&gt; Int in      </span><br><span class="line">      return  a + b</span><br><span class="line">  &#125;</span><br><span class="line">let product = moneyArray.reduce(1) &#123; (a : Int, b: Int) -&gt; Int in</span><br><span class="line">  return  a * b</span><br><span class="line">  &#125;</span><br><span class="line">   print(&quot;数组总和==\(result),数组乘积==\(product)”)</span><br></pre></td></tr></table></figure>
</li>
</ul>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//MARK: -- 最简约的写法，采用默认参数</span><br><span class="line">let sum = moneyArray.reduce(0) &#123; $0 + $1&#125;     </span><br><span class="line">let product = moneyArray.reduce(1) &#123; $0 * $1&#125;</span><br><span class="line">print(&quot;数组总和==\(result),数组乘积==\(product)”)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>特殊情况下可再简化 </p>
<p>上面的都不是最简化的，其实最简化地写法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//MARK:— Swift中操作符可用着函数，可简化成：</span><br><span class="line">let  sum = moneyArray.reduce(0, +)        </span><br><span class="line">let  product = moneyArray.reduce(1, *)</span><br><span class="line">print(&quot;数组总和==\(sum),数组乘积==\(product)&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  reduce可能是三个高阶函数中最难理解的一个。 需要注意的是nextPartialResult函数的两参数类型不同，Result为计算结果类型，Element为数组元素类型。</p>
<hr>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><ul>
<li><p>flatMap介绍</p>
<p> 比map更深一样，在自定义函数时，可能把元素生成更多的元素，然后会把这些元素都加到新的元素数组中去。</p>
</li>
<li><p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  let oldArray = [20,10,30]</span><br><span class="line"></span><br><span class="line">  let newArray = oldArray.flatMap &#123; (a : Int) -&gt; [String] in         </span><br><span class="line">  return [&quot;\(a)元&quot;,&quot;\(a)分&quot;]</span><br><span class="line">     &#125;   </span><br><span class="line">print(newArray)</span><br><span class="line">//  结果: [&quot;20元&quot;, &quot;20分&quot;, &quot;10元ƒ&quot;, &quot;10分&quot;, &quot;30元&quot;, &quot;30分”]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //MARK: -- 简约写法</span><br><span class="line">let newArray = oldArray.flatMap(&#123;[&quot;\($0)元&quot;,&quot;\($0)分&quot;]&#125;)</span><br><span class="line">print(newArray)       </span><br><span class="line">//  结果: [&quot;20元&quot;, &quot;20分&quot;, &quot;10元&quot;, &quot;10分&quot;, &quot;30元&quot;, &quot;30分”]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>对比map</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   let newArr = oldArray.map(&#123;[&quot;\($0)元&quot;,&quot;\($0)分&quot;]&#125;)     </span><br><span class="line">print (newArr)     </span><br><span class="line">//   结果: [[&quot;20元&quot;, &quot;20分&quot;], [&quot;10元&quot;, &quot;10分&quot;], [&quot;30元&quot;, &quot;30分&quot;]]</span><br></pre></td></tr></table></figure>
<p>对比一下结果就看出运算的不同之处了。map是由一个元素生成object，返回后替代原来的元素，数组的这个元素就成了是object，数组的这个元素就是object。而flatMap可以由一个元素生成一个数组newArr，结果数组在这个元素的位置插入newArr.count个数的newArr，结果数组的个数就增加了newArr.count元素了。</p>
<p>所以flatmap是map的扩展功能，因为它生成的不是单个元素，而可以是数组。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>数据比较大的时候，高阶函数会比传统实现更快，因为它可以并行执行（如运行在多核上），除非真的需要更高定制版本的map，reduce和filter，否则可以一直使用它们以获得更快的执行速度。</p>
</li>
<li><p>当使用map，filter，reduce的代码质量会更好。</p>
<p><a href="https://maojianxiang.github.io">小毛的博客</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/06/28/3D-Touch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/28/3D-Touch/" itemprop="url">
                  3D Touch
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T15:19:08+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  3D Touch是一种立体触控技术，被苹果称为新一代多点触控技术，是在Apple Watch上采用的Force Touch，屏幕可感应不同的感压力度触控。3D Touch，苹果iPhone 6s的新功能，系统版本需要iOS 9.0+ ，有Peek Pop 两种新手种势。</p>
<p>   2015年9月10日，苹果在新品发布会上宣布了3D-Touch功能。 2016年6月13日，苹果开发者大会WWDC在旧金山召开，会议宣布可以在待机画面用3D Touch操作通知。</p>
<p>现在，许多安卓手机也用上了3D Touch。</p>
<p>– 摘自<a href="http://baike.baidu.com/link?url=GB-HtIdALMiFhvBNnnlB2XIufZsONBza8ccrAQG7_4HQtWm_C6x9AEK3r1Ek6YJ4suVOsQoDqUb3HXc-ja6FO8ZVsrudKNtpNx6psKj1MtOsg7TOzx4_g0JuprFm82NUh9Az_an8U93KWfGXUNwhYa" target="_blank" rel="noopener">百度百科</a></p>
<hr>
<h3 id="3D-Touch四大功能模块"><a href="#3D-Touch四大功能模块" class="headerlink" title="3D Touch四大功能模块"></a>3D Touch四大功能模块</h3><ul>
<li><strong>Home Screen Quick Actions</strong> （主屏幕快捷入口）</li>
<li><strong>peek And pop</strong> （预览和弹出 展示框）</li>
<li><strong>Force Properties</strong> （按压力度属性）</li>
<li><strong>Web View peek and pop API</strong> (HTML链接预览功能)</li>
</ul>
<hr>
<h3 id="设备支持判断"><a href="#设备支持判断" class="headerlink" title="设备支持判断"></a>设备支持判断</h3><ul>
<li><p>所有遵守UITraitEnvironment(特征环境)协议的类，都会有UITraitCollection(特征集合类)的属性，都有forceTouchCapability(力的触觉能力)属性,<br>而UIResponder就遵守了UITraitEnvironment协议，所以所有继承于UIResponder的类都会使用3DTouch.包括UIView也可以使用</p>
</li>
<li><p>forceTouchCapability是枚举型</p>
</li>
</ul>
<ul>
<li><p>代码示例</p>
<p>示例代码* OC</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// UIForceTouchCapability：  </span><br><span class="line">typedef NS_ENUM(NSInteger, UIForceTouchCapability) &#123;</span><br><span class="line">   UIForceTouchCapabilityUnknown =0,  //3D Touch检测失败</span><br><span class="line">   UIForceTouchCapabilityUnavailable =1, //3D Touch不可用</span><br><span class="line">   UIForceTouchCapabilityAvailable =2  //3D Touch可用</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 判断是否支持：</span><br><span class="line">  if (self.traitCollection.forceTouchCapability !=UIForceTouchCapabilityAvailable) &#123;</span><br><span class="line">   UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:@&quot;设备不支持3DTouch&quot; delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil];</span><br><span class="line">   [alertView show];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>swift</li>
</ul>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> // UIForceTouchCapability:</span><br><span class="line"> public enum UIForceTouchCapability : Int&#123;</span><br><span class="line">  case unknown  //3D Touch检测失败</span><br><span class="line">  case unavailable  //3D Touch不可用</span><br><span class="line">  case available  //3D Touch可用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否支持：</span><br><span class="line"></span><br><span class="line">if traitCollection.forceTouchCapability != .available&#123;</span><br><span class="line">      </span><br><span class="line"> let alert =  UIAlertView(title: &quot;提示&quot;, message: &quot;设备不支持3DTouch&quot;, delegate: nil, cancelButtonTitle: &quot;确定&quot;)</span><br><span class="line"> alert.show()          </span><br><span class="line"> return   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Home-Screen-Quick-Actions开发"><a href="#Home-Screen-Quick-Actions开发" class="headerlink" title="Home Screen Quick Actions开发"></a>Home Screen Quick Actions开发</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p> 通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发,。如微信、京东的App，本文也将重点介绍这项开发技术。</p>
<p> 效果如下：</p>
<p> <img src="/2017/06/28/3D-Touch/120.png" alt=""></p>
<p>3D Touch快捷入口标签有两种添加方式：</p>
<ol>
<li><p>一种是静态添加，在工程中的info.plist文件中添加相关项目。通过这种方式添加的标签，在app第一次运行前，就可以唤出这些标签。</p>
</li>
<li><p>另一种是动态添加，通过代码给App添加快速入口。这种方式添加的标签，第一次运行App前是看不到这些标签的，必须先运行一次App,以后就可以唤出这些标签了。</p>
</li>
</ol>
<h4 id="静态添加快捷入口标签"><a href="#静态添加快捷入口标签" class="headerlink" title="静态添加快捷入口标签"></a>静态添加快捷入口标签</h4><ol>
<li><p>静态添加入口标签不需要写代码，只需要在info.plist文件中添加相关功能设置即可。不过因为没有语句提示，所以我们只能一个字母一个字母的去添加，这一点不是很友好。</p>
</li>
<li><p>示例</p>
<p><img src="/2017/06/28/3D-Touch/100.png" alt=""></p>
</li>
<li><p>说明</p>
<ul>
<li>首先是UIApplicationShortcutItems，他是一个数组类型，数组中的每一个元素表示一个入口标签。</li>
<li>每个Item是UIApplicationShortcutItems数组中的一个元素，字典类型。在这个字典中配置各个标签的相关属性。</li>
<li><p>如图如示</p>
<p><img src="/2017/06/28/3D-Touch/110.png" alt=""></p>
</li>
<li><p>效果如图</p>
<p><img src="/2017/06/28/3D-Touch/120.png" alt=""></p>
</li>
<li><p><em>注：UIApplicationShortcutItemIconFile：当填写上图片图标的我名字就可以显示出图标。</em></p>
</li>
</ul>
</li>
</ol>
<h4 id="动态添加快捷入口标签"><a href="#动态添加快捷入口标签" class="headerlink" title="动态添加快捷入口标签"></a>动态添加快捷入口标签</h4><h5 id="需要用到的类"><a href="#需要用到的类" class="headerlink" title="需要用到的类"></a>需要用到的类</h5><ul>
<li>如图<br><img src="/2017/06/28/3D-Touch/130.png" alt=""></li>
</ul>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><ul>
<li><p>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// UIApplicationShortcutIconType是系统的图片类型，29种类型图片</span><br><span class="line"> </span><br><span class="line">   UIApplicationShortcutIcon *shareShortcutIcon = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeShare];</span><br><span class="line"> </span><br><span class="line">   UIApplicationShortcutItem *shareShortcutItem = [[UIApplicationShortcutItem alloc] initWithType:@&quot;&quot; localizedTitle:@&quot;分享&quot; localizedSubtitle:@&quot;来点我啊&quot; icon:shareShortcutIcon userInfo:nil];</span><br><span class="line">  </span><br><span class="line">  //可以用iconWithTemplateImageName:来自定义图片 shortcut_QR:图片名</span><br><span class="line">   UIApplicationShortcutIcon *payShortcutIcon = [UIApplicationShortcutIcon iconWithTemplateImageName:@&quot;shortcut_imageName&quot;];</span><br><span class="line">      </span><br><span class="line">   UIApplicationShortcutItem *payShortcutItem = [[UIApplicationShortcutItem alloc] initWithType:@&quot;&quot; localizedTitle:@&quot;消息&quot; localizedSubtitle:@&quot;不怕不怕&quot; icon:payShortcutIcon userInfo:nil];</span><br><span class="line">    </span><br><span class="line">   //将实例化的shortcutItem将入到UIApplication的shortcutItems中就完成了。</span><br><span class="line">  [UIApplication sharedApplication].shortcutItems = @[shareShortcutItem, payShortcutItem];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//分享</span><br><span class="line">let icon1 = UIApplicationShortcutIcon(type: .share)</span><br><span class="line">let shareItem = UIApplicationShortcutItem(type: &quot;&quot;, localizedTitle: &quot;分享&quot;, localizedSubtitle: &quot;来点我&quot;, icon: icon1, userInfo: nil)</span><br><span class="line">         </span><br><span class="line">//支付 shortcut_imageName:图片名称</span><br><span class="line">let icon2 = UIApplicationShortcutIcon(templateImageName: &quot;shortcut_imageName&quot;)</span><br><span class="line">let playItem = UIApplicationShortcutItem(type: &quot;&quot;, localizedTitle: &quot;支付&quot;, localizedSubtitle: &quot;不怕不怕&quot;, icon: icon2, userInfo: nil)</span><br><span class="line">  </span><br><span class="line">UIApplication.shared.shortcutItems = [shareItem,playItem]</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIApplicationShortcutIconType补充说明</p>
<p>系统一共提供了29种类型样式：</p>
<p>typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) {<br>  UIApplicationShortcutIconTypeCompose,<br>  UIApplicationShortcutIconTypePlay,<br>  UIApplicationShortcutIconTypePause,<br>  UIApplicationShortcutIconTypeAdd,<br>  UIApplicationShortcutIconTypeLocation,<br>  UIApplicationShortcutIconTypeSearch,<br>  UIApplicationShortcutIconTypeShare,</p>
<p>  UIApplicationShortcutIconTypeProhibit,   //从这开始，iOS 9.1+才支持<br>  UIApplicationShortcutIconTypeContact,<br>  UIApplicationShortcutIconTypeHome,<br>  UIApplicationShortcutIconTypeMarkLocation,<br>  UIApplicationShortcutIconTypeFavorite,<br>  UIApplicationShortcutIconTypeLove,<br>  UIApplicationShortcutIconTypeCloud,<br>  UIApplicationShortcutIconTypeInvitation,<br>  UIApplicationShortcutIconTypeConfirmation,<br>  UIApplicationShortcutIconTypeMail,<br>  UIApplicationShortcutIconTypeMessage,<br>  UIApplicationShortcutIconTypeDate,<br>  UIApplicationShortcutIconTypeTime,<br>  UIApplicationShortcutIconTypeCapturePhoto,<br>  UIApplicationShortcutIconTypeCaptureVideo,<br>  UIApplicationShortcutIconTypeTask,<br>  UIApplicationShortcutIconTypeTaskCompleted,<br>  UIApplicationShortcutIconTypeAlarm,<br>  UIApplicationShortcutIconTypeBookmark,<br>  UIApplicationShortcutIconTypeShuffle,<br>  UIApplicationShortcutIconTypeAudio,<br>  UIApplicationShortcutIconTypeUpdate<br>}  </p>
</li>
</ul>
<h4 id="快捷启动后的处理-检测App启动方式"><a href="#快捷启动后的处理-检测App启动方式" class="headerlink" title="快捷启动后的处理(检测App启动方式)"></a>快捷启动后的处理(检测App启动方式)</h4><h5 id="代理接受"><a href="#代理接受" class="headerlink" title="代理接受"></a>代理接受</h5><p>  通过快捷入口进入或者启动app,会实现appDelegate的代理方法:</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandle</span><br></pre></td></tr></table></figure>
<p>  我们可以判断shortcutItem.localizedTitle属性的值来判断是从哪一个标签进入的App。</p>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><ul>
<li><p>OC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   - (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler &#123;</span><br><span class="line">      </span><br><span class="line">      //如果是从&quot;分享&quot;这个标签进来的，我们把页面背景颜色修改为黄色，如果是从@&quot;消息&quot;这个标签进来的，我们讲页面背景颜色修改为红色。都不是的话，就直接是白色。</span><br><span class="line">    if  ([shortcutItem.localizedTitle isEqualToString:@&quot;分享&quot;]) &#123;       </span><br><span class="line">        self.window.rootViewController.view.backgroundColor = [UIColor yellowColor];</span><br><span class="line">      &#125; else if ([shortcutItem.localizedTitle isEqualToString:@&quot;消息&quot;]) &#123;       </span><br><span class="line">        self.window.rootViewController.view.backgroundColor = [UIColor redColor];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123;</span><br><span class="line"></span><br><span class="line">      if shortcutItem.localizedTitle == &quot;来啊&quot;&#123;     </span><br><span class="line">      window?.rootViewController?.view.backgroundColor= #colorLiteral(red: 1, green: 0, blue: 0, alpha: 1)</span><br><span class="line">      &#125;else if shortcutItem.localizedTitle == &quot;后门&quot; &#123;  </span><br><span class="line">      window?.rootViewController?.view.backgroundColor= #colorLiteral(red: 0.2196078449, green: 0.007843137719, blue: 0.8549019694, alpha: 1)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul>
<li><p>UIApplicationLaunchOptionsShortcutItemKey</p>
<p>在- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(nullable NSDictionary </em>)launchOptions的方法中 。launchOptions 中有个值为UIApplicationLaunchOptionsShortcutItemKey，这个也是获取选择的shortcutItem的方法。</p>
</li>
<li><p>注意</p>
<ol>
<li>快捷入口 无论是启动app,还是将后台运行的app转为前台都会执行代理方法。</li>
<li><p>反之，如果快捷入口 是将后台运行的app转为前台都会执行代理方法。是不会走didFinishLaunchingWithOptions:的方法。</p>
</li>
<li><p>总结:</p>
<p><strong>我们处理Home Screen Quick Actions功能时最好统一在代理回调的方法里处理。如果在遇到特殊功能，需要判明该功能是启动了整个app时，我们就可以在didFinishLaunchingWithOptions:的时候来判断加以处理！</strong></p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="peek-And-pop"><a href="#peek-And-pop" class="headerlink" title="peek And pop"></a>peek And pop</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>效果演示：</p>
<ol>
<li><p>进 “邮件” 收件箱列表：</p>
<p><img src="/2017/06/28/3D-Touch/140.png" alt=""></p>
</li>
<li><p>按住环信发过来的邮件，力度慢慢增加，会pop出详情效果框：</p>
<p> <img src="/2017/06/28/3D-Touch/150.png" alt=""></p>
</li>
<li><p>再使劲达到它的力度，就会等同于你选择了该项，进入详情页面了。</p>
</li>
</ol>
</li>
</ul>
<h4 id="功能的基本思路："><a href="#功能的基本思路：" class="headerlink" title="功能的基本思路："></a>功能的基本思路：</h4><ol>
<li>控制器注册预览协议(UIViewControllerPreviewingDelegate)</li>
<li>遵守协议并实现其必须实现的方法</li>
</ol>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><ul>
<li><p>OC</p>
<ol>
<li><p>注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> // self：为视图控制器, soureView: 为实现3DTouch的视图，如果是单独的一个view的话，则效果只对该view有作用， 那到时的gesture和location都是相对于这个soureView的。</span><br><span class="line">[self registerForPreviewingWithDelegate:self sourceView:self.view];</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<pre><code>2. 遵守代理

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&lt;UIViewControllerPreviewingDelegate&gt;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">   //MARK: — UIViewControllerPreviewingDelegate</span><br><span class="line">   //MARK: -- 返回要显示的控制器</span><br><span class="line">   - (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123;</span><br><span class="line"></span><br><span class="line">   //初始化要显示的控制器</span><br><span class="line">    UIViewController *childVc = [[UIViewController alloc]init];</span><br><span class="line"></span><br><span class="line">   //1.获取手势,我在view上加了一个tableView，这里我是想要获取我们重按的点是点在哪个cell上。</span><br><span class="line">   UIGestureRecognizer *gesture  =  previewingContext.previewingGestureRecognizerForFailureRelationship;</span><br><span class="line">  //2.获取手势所在的tableView中的点位</span><br><span class="line">CGPoint point = [gesture locationInView:self.tableView];</span><br><span class="line">   //3. 根据这个点获取是第几行,    ROWHight是单个cell的高度</span><br><span class="line">NSInteger index = floor(point.y/ROWHight);</span><br><span class="line">   //4.得到第行，而且得到cell</span><br><span class="line">self.indexPath = [NSIndexPath indexPathForRow:index inSection:0];  </span><br><span class="line">self.cell =[self.tableView cellForRowAtIndexPath:self.indexPath];</span><br><span class="line">   </span><br><span class="line"> // 加个白色背景,这个背影是高清显示的。</span><br><span class="line">UIView *bgView =[[UIView alloc] initWithFrame:CGRectMake(20, 10, kScreenWidth - 40,kScreenHeight - 20 - 64 * 2)];</span><br><span class="line">    bgView.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    bgView.layer.cornerRadius = 10;</span><br><span class="line">    bgView.clipsToBounds = YES;</span><br><span class="line">    [childVc.view addSubview:bgView];</span><br><span class="line">   </span><br><span class="line">  //展示的标题</span><br><span class="line">UILabel *lable1 = [[UILabel alloc] initWithFrame:CGRectMake(0,bgView.bounds.size.height/2-40 , bgView.bounds.size.width, 40)];</span><br><span class="line">    lable1.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    lable1.textColor=[UIColor redColor];</span><br><span class="line">    lable1.text = self.cell.textLabel.text;</span><br><span class="line">    [bgView addSubview:lable1];</span><br><span class="line">   </span><br><span class="line">  // 展示的详情</span><br><span class="line">UILabel *lable2 = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(lable1.frame), bgView.bounds.size.width, 40)];</span><br><span class="line">    lable2.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    lable2.textColor = [UIColor lightGrayColor];</span><br><span class="line">   NSString *text = self.cell.detailTextLabel.text;</span><br><span class="line">    lable2.text= text;</span><br><span class="line">    [bgView addSubview:lable2];</span><br><span class="line">     </span><br><span class="line"> //提示lable</span><br><span class="line">UILabel *detail = [[UILabel alloc] initWithFrame:CGRectMake(0, CGRectGetMaxY(lable2.frame), bgView.bounds.size.width, 40)];</span><br><span class="line">    detail.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    detail.textColor=[UIColor yellowColor];</span><br><span class="line">    detail.text = @&quot;再按重一点就选择该项了&quot;;</span><br><span class="line">    [bgView addSubview: detail];   </span><br><span class="line"></span><br><span class="line">  //最后返回的展示的控制器</span><br><span class="line">    return  childVc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //MARK: -- 再次重按的时候表示进行选择了，然后消失后会下走的方法</span><br><span class="line">  - (void)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController*)viewControllerToCommit&#123;</span><br><span class="line">   </span><br><span class="line">  //让它走选择了某项的代理方法。</span><br><span class="line">    [self tableView:self.tableView didSelectRowAtIndexPath:self.indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h4><ul>
<li>location是相对于注册source来获取的。</li>
<li><p>UIViewControllerPreviewing 主要可用的属性,是相对于注册source的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly) UIGestureRecognizer *previewingGestureRecognizerForFailureRelationship //手势</span><br><span class="line">@property (nonatomic, readonly) UIView *sourceView  //source当初注册传入的视图</span><br><span class="line">@property (nonatomic) CGRect sourceRect  //source的frame</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>注册的时候直接用SourceView为Cell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        //MARK:-- 返回cell</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath&#123;</span><br><span class="line">    </span><br><span class="line">     UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellID forIndexPath:indexPath];</span><br><span class="line">      if(cell) &#123;</span><br><span class="line">           cell.textLabel.text = self.dataSouce[indexPath.row][@&quot;title&quot;];</span><br><span class="line">           cell.detailTextLabel.text  = self.dataSouce[indexPath.row][@&quot;detail&quot;];</span><br><span class="line">           [self registerForPreviewingWithDelegate:self sourceView:cell];</span><br><span class="line">          &#125;</span><br><span class="line">       return  cell;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 2.在代理中获取点击cell就简单多了</span><br><span class="line">- (nullable UIViewController *)previewingContext:(id &lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123;  </span><br><span class="line">  </span><br><span class="line"> UIViewController *childVc = [[UIViewController alloc]init];   </span><br><span class="line"></span><br><span class="line">  // 方法一：  </span><br><span class="line">self.cell  = (UITableViewCell *) previewingContext.sourceView;//这个可以获取注册的sourceView</span><br><span class="line">CGRect frame = previewingContext.sourceRect;//这个可以获取注册的sourceView.frame及大小</span><br><span class="line"></span><br><span class="line"> //  方法二：</span><br><span class="line"> //  UIGestureRecognizer *gesture  =  previewingContext.previewingGestureRecognizerForFailureRelationship;//    //2.获取手势</span><br><span class="line"> //   UIGestureRecognizer *gesture  =  previewingContext.previewingGestureRecognizerForFailureRelationship;//    //2.获取手势所在的tableView中的点位</span><br><span class="line">//    self.cell   = (UITableViewCell *)gesture.view;//这个可以获取点击所得到的cell;</span><br><span class="line">  </span><br><span class="line"> return    childVc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Swift </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">  class NexViewController: UIViewController&#123;</span><br><span class="line">let CellId = &quot;CellId&quot;</span><br><span class="line">var currentCell : UITableViewCell?</span><br><span class="line"></span><br><span class="line"> @IBOutlet weak var tableView: UITableView!</span><br><span class="line">   </span><br><span class="line"> var dataSource : [[String : Any]] = [];</span><br><span class="line">    </span><br><span class="line"> override func viewDidLoad() &#123;</span><br><span class="line">       super.viewDidLoad()</span><br><span class="line">       getData()</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"> //遵守协议</span><br><span class="line">extension NexViewController : UITableViewDataSource,UITableViewDelegate,UIViewControllerPreviewingDelegate</span><br><span class="line">&#123;   </span><br><span class="line">   //TODO: -- 加载数据</span><br><span class="line">       func getData() &#123;</span><br><span class="line">            for i in 0..&lt;20&#123;</span><br><span class="line">              let dic = [&quot;title&quot; : &quot;测试标题 + \(i+1)&quot;, &quot;detail&quot; : &quot;详情资料是这样的 + \(i+1)&quot;];</span><br><span class="line">              dataSource.append(dic)</span><br><span class="line">        &#125;</span><br><span class="line">       tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> //MARK: -- UITableViewDataSource</span><br><span class="line"> //TODO:-- 每个section有多少条</span><br><span class="line"> public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int</span><br><span class="line">&#123;</span><br><span class="line">    return dataSource.count</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line"> //TODO:-- 返回Cell   </span><br><span class="line">public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell</span><br><span class="line">&#123;</span><br><span class="line">       let cell = tableView.dequeueReusableCell(withIdentifier: CellId, for: indexPath)</span><br><span class="line">     cell.textLabel?.text = (dataSource[indexPath.row] as! Dictionary)[&quot;title&quot;]</span><br><span class="line">     cell.detailTextLabel?.text = (dataSource[indexPath.row] as! Dictionary)[&quot;detail”]</span><br><span class="line"></span><br><span class="line"> // 注册3DTouch</span><br><span class="line">     registerForPreviewing(with: self, sourceView: cell)</span><br><span class="line">     return  cell    </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> //TODO: -- UITableViewDelegate     public func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)&#123;</span><br><span class="line">      tableView.deselectRow(at: indexPath, animated: true)</span><br><span class="line">      performSegue(withIdentifier: &quot;detail&quot;, sender: dataSource[indexPath.row])</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"> //重写segue跳转方法</span><br><span class="line">   override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;      </span><br><span class="line">   if segue.identifier == “detail&quot;&#123;</span><br><span class="line">           if let viewcontroller = segue.destination as? DetailViewController&#123;</span><br><span class="line">              viewcontroller.info = sender as! [String : Any]?</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> //MARK: -- UIViewControllerPreviewingDelegate     </span><br><span class="line">public func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController?&#123;</span><br><span class="line">    </span><br><span class="line">   let childVC  = UIViewController()</span><br><span class="line">   currentCell = previewingContext.sourceView as? UITableViewCell</span><br><span class="line"></span><br><span class="line">  //TODO: -- 加白色背景</span><br><span class="line">        let bgView = UIView(frame: .init(x: 20, y: 10, width: (view.window?.bounds.size.width)!-40 , height: (view.window?.bounds.size.height)! - 20-64*2))</span><br><span class="line">        bgView.backgroundColor= #colorLiteral(red: 1, green: 1, blue: 1, alpha: 1)</span><br><span class="line">        bgView.layer.cornerRadius = 10.0</span><br><span class="line">        bgView.clipsToBounds = true</span><br><span class="line">       childVC.view.addSubview(bgView)</span><br><span class="line">      </span><br><span class="line"> // 标题</span><br><span class="line">    let lable1 = UILabel(frame: .init(x: 0, y: bgView.bounds.size.height/2 - 40, width: bgView.bounds.size.width, height: 40))</span><br><span class="line">     lable1.textAlignment = .center</span><br><span class="line">     lable1.textColor = #colorLiteral(red: 0.8078431487, green: 0.02745098062, blue: 0.3333333433, alpha: 1)</span><br><span class="line">     lable1.text = currentCell?.textLabel?.text</span><br><span class="line">     bgView.addSubview(lable1)</span><br><span class="line">        </span><br><span class="line"> //详情      </span><br><span class="line">    let lable2 = UILabel(frame: .init(x: 0, y: lable1.frame.maxY, width: bgView.bounds.size.width, height: 40))</span><br><span class="line">    lable2.textAlignment = .center</span><br><span class="line">    lable2.textColor = #colorLiteral(red: 0.501960814, green: 0.501960814, blue: 0.501960814, alpha: 1)</span><br><span class="line">    lable2.text = currentCell?.detailTextLabel?.text</span><br><span class="line">    bgView.addSubview(lable2)</span><br><span class="line">       </span><br><span class="line"> //提示      </span><br><span class="line">   let detail = UILabel(frame: .init(x: 0, y: lable2.frame.maxY, width: bgView.bounds.size.width, height: 40))</span><br><span class="line">   detail.textAlignment = .center</span><br><span class="line">   detail.textColor= #colorLiteral(red: 0.9529411793, green: 0.6862745285, blue: 0.1333333403, alpha: 1)</span><br><span class="line">   detail.text = &quot;再按重一点就选择该项了&quot;</span><br><span class="line">   bgView.addSubview(detail)</span><br><span class="line">              </span><br><span class="line"> return childVC</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">   //再按重些会选择该项，消失展示框后需要走的代码</span><br><span class="line">public func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController)&#123;</span><br><span class="line">  </span><br><span class="line"> let indexPath = tableView.indexPath(for: currentCell!)  </span><br><span class="line"> if indexPath != nil&#123;</span><br><span class="line">    tableView(tableView, didSelectRowAt: indexPath!)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="Force-Properties-力量属性"><a href="#Force-Properties-力量属性" class="headerlink" title="Force Properties 力量属性"></a>Force Properties 力量属性</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>iOS9为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理。例如，我们可以通过力度来控制快进的快慢，音量增加的快慢等。</p>
<p>UITouch新增了两个属性：</p>
<ul>
<li>open var force: CGFloat{ get }    //force ： 手指按下的力度</li>
<li><p>open var maximumPossibleForce: CGFloat { get }  //maximumPossibleForce ： 最大可能的力度</p>
<p>在touch中就可以获取这两个值。所以我们就可以触摸按压的时候实现用按压力度来实现酷炫的效果</p>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4></li>
<li><p>OC </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 根据按压的力度来改变当前视图的颜色</span><br><span class="line">-  (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent*)event&#123;</span><br><span class="line"></span><br><span class="line">    if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) &#123;  </span><br><span class="line">     UITouch *touch = [[touches allObjects] firstObject];</span><br><span class="line">     NSLog(@&quot;\n force:%f,maximumPossibleForce:%ff&quot;,touch.force,touch.maximumPossibleForce);</span><br><span class="line">     CGFloat dito = touch.force/touch.maximumPossibleForce;</span><br><span class="line">     self.view.backgroundColor = [UIColor colorWithRed:dito green:dito blue:1/dito alpha:1];</span><br><span class="line">  </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Swift </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> //TODO:--重写touchesMoved的方法,根据按压的力度来改变当前视图的颜色</span><br><span class="line">override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;</span><br><span class="line">        </span><br><span class="line">     if traitCollection.forceTouchCapability == .available&#123;  </span><br><span class="line">           let touch = touches.first</span><br><span class="line">           print(&quot;\n force: \(touch!.force),maximumPossibleForce: \(touch?.maximumPossibleForce)&quot;)</span><br><span class="line">           let dito = (touch?.force)! / (touch?.maximumPossibleForce)!</span><br><span class="line">           view.backgroundColor = UIColor(red: 0.3+5*dito, green: 0.3+5*dito, blue: dito, alpha:1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="Web-View-peek-and-pop-API-HTML链接预览功能"><a href="#Web-View-peek-and-pop-API-HTML链接预览功能" class="headerlink" title="Web View peek and pop API HTML链接预览功能"></a>Web View peek and pop API HTML链接预览功能</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p> 原生的safari浏览器中的超链接可以支持3D touch，出现超链接的预览，使用方法和前文中提到的方法类似。ios 9 中增加了一个新的浏览器控制器SFSafariViewController。它可以在你的程序中直接嵌入 Safari浏览器，而且支持3DTouch效果。</p>
<h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><ul>
<li><p>OC </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1.首先导入SafariServices.h</span><br><span class="line">   #import &lt;SafariServices/SafariServices.h&gt;</span><br><span class="line"></span><br><span class="line"> // 2.设置连接：</span><br><span class="line"> SFSafariViewController *safariView = [[SFSafariViewController alloc] initWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]        entersReaderIfAvailable:YES];</span><br><span class="line"></span><br><span class="line"> // 3.推出控制器：</span><br><span class="line">  [self.navigationController pushViewController:safariView animated:YES];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Swift</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> // 1. 导入框架</span><br><span class="line">import SafariServices</span><br><span class="line"></span><br><span class="line"> // 2. 使用</span><br><span class="line">let url = URL(string: &quot;https://www.baidu.com&quot;)     </span><br><span class="line">let safariView =  SFSafariViewController(url: url! , entersReaderIfAvailable: true)</span><br><span class="line">navigationController?.pushViewController(safariView, animated: true)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>3D Touch确实挺炫酷的，特别是<strong>Home Screen Quick Actions</strong>(主屏幕快捷入口)和<br><strong>peek And pop</strong>(预览和弹出功能),增加了用户体验。</p>
<p> 这里我只是简单地介绍了它的使用,如有疑问请Q我: <strong>342112780</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/06/28/iOS手电筒功能开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/28/iOS手电筒功能开发/" itemprop="url">
                  iOS手电筒功能开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T14:18:34+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> AVCaptureDevice(捕捉设备类)可以完成手机手电筒功能的开发，它属于AVFoundation框架。开发也比较简单，我这里简单地介绍一下。</p>
<hr>
<h3 id="OC中的代码示例"><a href="#OC中的代码示例" class="headerlink" title="OC中的代码示例"></a>OC中的代码示例</h3><h4 id="导入框架"><a href="#导入框架" class="headerlink" title="导入框架"></a>导入框架</h4><pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;
</code></pre><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><pre><code>@property(nonatomic,strong)AVCaptureDevice *device;
@property(nonatomic,assign)BOOL available;
</code></pre><h4 id="初始化捕捉设备对象"><a href="#初始化捕捉设备对象" class="headerlink" title="初始化捕捉设备对象"></a>初始化捕捉设备对象</h4><pre><code>//初始化捕捉设备对象
self.device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
</code></pre><h4 id="手电筒功能是否可用"><a href="#手电筒功能是否可用" class="headerlink" title="手电筒功能是否可用"></a>手电筒功能是否可用</h4><pre><code> //获取是否可用手电筒功能
 self.available = self.device.hasTorch;
//提示
if (!self.available) {
    UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:@&quot;设备不可用&quot; delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil];
    [alertView show];
}
</code></pre><h4 id="打开手电筒"><a href="#打开手电筒" class="headerlink" title="打开手电筒"></a>打开手电筒</h4><pre><code> if (self.available) {
    [self.device lockForConfiguration:nil];
    // AVCaptureTorchModeOn:开 AVCaptureTorchModeOff:关 AVCaptureTorchModeAuto:自动
    self.device.torchMode = AVCaptureTorchModeOn;
    [self.device unlockForConfiguration];
}
</code></pre><h4 id="关闭手电筒"><a href="#关闭手电筒" class="headerlink" title="关闭手电筒"></a>关闭手电筒</h4><pre><code> if (self.available) {
    [self.device lockForConfiguration:nil];
    // AVCaptureTorchModeOn:开 AVCaptureTorchModeOff:关 AVCaptureTorchModeAuto:自动
    self.device.torchMode = AVCaptureTorchModeOff;
    [self.device unlockForConfiguration];
}
</code></pre><hr>
<h3 id="Switf中的代码示例-跟OC同理"><a href="#Switf中的代码示例-跟OC同理" class="headerlink" title="Switf中的代码示例(跟OC同理)"></a>Switf中的代码示例(跟OC同理)</h3><h4 id="导入框架-1"><a href="#导入框架-1" class="headerlink" title="导入框架"></a>导入框架</h4><pre><code>import AVFoundation
</code></pre><h4 id="定议成属性并懒加载捕捉设备对象"><a href="#定议成属性并懒加载捕捉设备对象" class="headerlink" title="定议成属性并懒加载捕捉设备对象"></a>定议成属性并懒加载捕捉设备对象</h4><pre><code>var isflashlight = false
lazy var device:AVCaptureDevice? = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)
</code></pre><h4 id="手电筒功能是否可用-1"><a href="#手电筒功能是否可用-1" class="headerlink" title="手电筒功能是否可用"></a>手电筒功能是否可用</h4><pre><code> //MARK: -- 是否支持手电筒功能
func supportFlashlight(){
    isflashlight = device?.hasTorch ?? false
    if !isflashlight {
    let alert =  UIAlertView(title: &quot;提示&quot;, message: &quot;设备不支持&quot;, delegate: nil, cancelButtonTitle: &quot;确定&quot;)
    alert.show()
    }  
}
</code></pre><h4 id="打开或者关闭手电筒"><a href="#打开或者关闭手电筒" class="headerlink" title="打开或者关闭手电筒"></a>打开或者关闭手电筒</h4><pre><code>//MARK: -- true:为打开，false:为关闭

func flashlight(_ sure : Bool ) {
    if sure {
        //打开
        do {
            try device!.lockForConfiguration()
            device!.torchMode = AVCaptureTorchMode.on
            device!.unlockForConfiguration()
         } catch  {

          }

    }else{
        //关闭
         do {
            try device!.lockForConfiguration()
            device!.torchMode = AVCaptureTorchMode.off
            device!.unlockForConfiguration()
         } catch  {

          }

     }
}
</code></pre><hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 是不是特别简单啊？如果有什么疑问可以Q我:<strong>342112780</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/06/20/遇到的问题-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/遇到的问题-1/" itemprop="url">
                  遇到的问题集 1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T17:11:26+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debug/" itemprop="url" rel="index">
                    <span itemprop="name">Debug</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="制作证书时报错"><a href="#制作证书时报错" class="headerlink" title="制作证书时报错"></a>制作证书时报错</h3><p>   如图<br>   <img src="/2017/06/20/遇到的问题-1/100.png" alt=""></p>
<p>   这个原因是在使用钥匙串时， <strong>证书助理</strong> -&gt; <strong>颁发机构申请</strong>   -&gt; 证书填写信息的时候少写了”<strong>常用名</strong>“导致的，把常用名称加上就可以了。</p>
<p><img src="/2017/06/20/遇到的问题-1/200.png" alt=""></p>
<hr>
<h3 id="真机运行时报错"><a href="#真机运行时报错" class="headerlink" title="真机运行时报错"></a>真机运行时报错</h3><p>  Xcode will continue when “iPhone名称” is finished.<br>    解决方法：重新拔一下真机，再重启一下Xcode,读取完就好了。</p>
<hr>
<h3 id="使用相机时报错"><a href="#使用相机时报错" class="headerlink" title="使用相机时报错"></a>使用相机时报错</h3><p> contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.</p>
<p> 在info.plist文件中给 NSCameraUsageDescription(Privacy - Camera Usage Description） 添加key,即提示用户应用将使用您的相机。如图：</p>
<p>  <img src="/2017/06/20/遇到的问题-1/300.png" alt=""></p>
<hr>
<h3 id="UIScrollView上加子视图的坑"><a href="#UIScrollView上加子视图的坑" class="headerlink" title="UIScrollView上加子视图的坑"></a>UIScrollView上加子视图的坑</h3><p>  注意: 在控制器里要设置self.automaticallyAdjustsScrollViewInsets=NO;<br>   不然添加的子视图位置会变。</p>
<hr>
<h3 id="我们在开发中经常还是要好好看看打印台信息"><a href="#我们在开发中经常还是要好好看看打印台信息" class="headerlink" title="我们在开发中经常还是要好好看看打印台信息"></a>我们在开发中经常还是要好好看看打印台信息</h3><pre><code>在网络请求无反应，没有注意打印台的同志，可能还到处打断点调试。

App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&apos;s Info.plist file.
</code></pre><p>  不必详说，这个是从Xcode 7开始开发对网络请求的限制。需要配置一下：</p>
<p> <img src="/2017/06/20/遇到的问题-1/400.png" alt=""></p>
<hr>
<h3 id="控制台打印报错"><a href="#控制台打印报错" class="headerlink" title="控制台打印报错"></a>控制台打印报错</h3><p>程序崩溃并在打印台显示信息：[aqme] 255: AQDefaultDevice (173): skipping input stream 0 0 0x0</p>
<p><strong>解决方法:</strong></p>
<ol>
<li>选择 Product –&gt;Scheme–&gt;Edit Scheme</li>
<li>选择 Arguments</li>
<li>在Environment Variables添加一个环境变量<br>OS_ACTIVITY_MODE 设置值为”disable”</li>
</ol>
<p><strong>设置值为”disable”</strong></p>
<hr>
<h3 id="linker-command-failed-with-exit-code-1-use-v-to-see-invocation-报错"><a href="#linker-command-failed-with-exit-code-1-use-v-to-see-invocation-报错" class="headerlink" title="linker command failed with exit code 1 (use -v to see invocation)报错"></a>linker command failed with exit code 1 (use -v to see invocation)报错</h3><ol>
<li><p>第一是三方库文件不支持，</p>
<p>但是在信息中，你会发现提示为三方名称，看报错详情可以查出来。这时三方库，可以是缺少依赖的库，也可能是三言库不支持当前的框架，模拟器的i386(32位),X86_64(64位),真机：armv7，armv7s （32位） ，arm64(64位)。</p>
</li>
<li><p>工程文件中，有名字为相同的。</p>
<p>这个情况一定要注意。因为报错都不知道报的是什么。<br>例：<br> <img src="/2017/06/20/遇到的问题-1/500.png" alt="">   </p>
</li>
</ol>
<hr>
<h3 id="Xcode-错误-Could-not-launch-app-No-such-file-or-directory-Error"><a href="#Xcode-错误-Could-not-launch-app-No-such-file-or-directory-Error" class="headerlink" title="Xcode 错误- Could not launch app - No such file or directory Error."></a>Xcode 错误- Could not launch app - No such file or directory Error.</h3><p>蛋疼的一个XCode bug，基本上应该不是工程本身问题。</p>
<p><strong>解决方法:</strong></p>
<ol>
<li>拔掉设备，删除之前Build的内容</li>
<li>退出Xcode，不是关闭窗口</li>
<li><p>删除那个/Users/XXX/Library/Developer/Xcode/DerivedData/XXX-grgrmtzqajhyqgghabyjttajwbsm文件夹</p>
</li>
<li><p>启动XCode连接设备，现在应该OK了</p>
</li>
</ol>
<hr>
<h3 id="Cannot-assign-to-‘self’-outside-of-a-method-in-the-init-family"><a href="#Cannot-assign-to-‘self’-outside-of-a-method-in-the-init-family" class="headerlink" title="Cannot assign to ‘self’ outside of a method in the init family"></a>Cannot assign to ‘self’ outside of a method in the init family</h3><p>当使用xib的时候，想自定义一个方来初始化对象View.初始化的名字的方法：以init +大写字母开头+其他。不然就会把这个错。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/06/20/系统自带的按钮风格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/系统自带的按钮风格/" itemprop="url">
                  系统自带的按钮风格
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T16:27:34+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="UIButton的风格"><a href="#UIButton的风格" class="headerlink" title="UIButton的风格"></a>UIButton的风格</h3><p> UIButton的风格不多，只有几种样式 </p>
<ol>
<li>UIButtonTypeCustom = 0,  //自定义风格</li>
<li>UIButtonTypeRoundedRect, //圆角矩形 </li>
<li>UIButtonTypeDetailDisclosure, //蓝色小箭头按钮，主要做详细说明用</li>
<li>UIButtonTypeInfoLight, //亮色感叹号</li>
<li>UIButtonTypeInfoDark, //暗色感叹号</li>
<li>UIButtonTypeContactAdd, //十字加号按钮</li>
</ol>
<h3 id="UIBarButtonItem风格就比较多"><a href="#UIBarButtonItem风格就比较多" class="headerlink" title="UIBarButtonItem风格就比较多"></a>UIBarButtonItem风格就比较多</h3><p> UIBarButtonSystemItem：</p>
<ul>
<li><p>UIBarButtonSystemItemDone<br><img src="/2017/06/20/系统自带的按钮风格/100.jpg" alt=""></p>
</li>
<li><p>UIBarButtonSystemItemCancel<br><img src="/2017/06/20/系统自带的按钮风格/101.jpg" alt=""></p>
</li>
<li><p>UIBarButtonSystemItemEdit<br><img src="/2017/06/20/系统自带的按钮风格/102.jpg" alt=""></p>
</li>
<li><p>UIBarButtonSystemItemSave<br><img src="/2017/06/20/系统自带的按钮风格/103.jpg" alt=""></p>
</li>
<li><p>UIBarButtonSystemItemAdd<br><img src="/2017/06/20/系统自带的按钮风格/104.jpg" alt=""></p>
</li>
<li><p>UIBarButtonSystemItemFlexibleSpace</p>
<p>无样式</p>
</li>
</ul>
<ul>
<li><p>UIBarButtonSystemItemFixedSpace</p>
<p> 无样式</p>
</li>
</ul>
<ul>
<li>UIBarButtonSystemItemCompose<br><img src="/2017/06/20/系统自带的按钮风格/105.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemReply<br><img src="/2017/06/20/系统自带的按钮风格/106.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemAction<br><img src="/2017/06/20/系统自带的按钮风格/107.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemOrganize<br><img src="/2017/06/20/系统自带的按钮风格/108.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemBookmarks<br><img src="/2017/06/20/系统自带的按钮风格/109.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemSearch<br><img src="/2017/06/20/系统自带的按钮风格/110.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemRefresh<br><img src="/2017/06/20/系统自带的按钮风格/111.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemStop<br><img src="/2017/06/20/系统自带的按钮风格/112.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemCamera<br><img src="/2017/06/20/系统自带的按钮风格/113.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemTrash<br><img src="/2017/06/20/系统自带的按钮风格/114.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemPlay<br><img src="/2017/06/20/系统自带的按钮风格/115.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemPause<br><img src="/2017/06/20/系统自带的按钮风格/116.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemRewind<br><img src="/2017/06/20/系统自带的按钮风格/117.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemFastForward<br><img src="/2017/06/20/系统自带的按钮风格/118.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemUndo<br><img src="/2017/06/20/系统自带的按钮风格/119.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemRedo<br><img src="/2017/06/20/系统自带的按钮风格/120.jpg" alt=""></li>
</ul>
<ul>
<li>UIBarButtonSystemItemPageCurl<br><img src="/2017/06/20/系统自带的按钮风格/121.jpg" alt=""></li>
</ul>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/06/20/大括号{}和小括号()的作用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/大括号{}和小括号()的作用/" itemprop="url">
                  大括号{}和小括号()的作用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T15:50:43+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/others/" itemprop="url" rel="index">
                    <span itemprop="name">others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UILabel *l = (&#123;</span><br><span class="line"></span><br><span class="line">        UILabel *label  = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 300, 25)];</span><br><span class="line"> </span><br><span class="line">        label.text = @&quot;Hello world&quot;;</span><br><span class="line"></span><br><span class="line">        [self.view addSubview: label];</span><br><span class="line">   </span><br><span class="line">        label;</span><br><span class="line">   </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>执行代码都放在大括号和小括号的中间的。而且运行我们会发现最后l也是被赋值成功的。</p>
<ul>
<li><p>总结<br> 这样可以深思一下{}和()各有什么作用</p>
<ol>
<li><p><em>{}包装代码</em></p>
<p> 大家在写程序的时候不难发现，在OC函数方法都用它来包括在里面，包括block也是被大括号包在里面的。所以，它的主要作用就是用来包装代码块。</p>
</li>
<li><p><em>()执行代码</em></p>
<p>在执行代码后，你会发现大括号中的代码都执行了，这就是因为小括号的原因。小括号的作用跟js，swift，以及java中其实感觉都是一样的，代码执行某个函数，只不过这里传入的不像参数，其他也可以把代码块当作参数。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UITableView *tableView = (&#123;</span><br><span class="line">        </span><br><span class="line">       UITableView *tabV = [[UITableView alloc]initWithFrame:CGRectMake(0, 0, 300, 200)];</span><br><span class="line">        </span><br><span class="line">      //最末尾的tabV会给tableView 赋值</span><br><span class="line">        tabV;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://maojianxiang.github.io/2017/06/20/查看代码行数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小毛纯一郎">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://on55qmgxp.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小毛的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/查看代码行数/" itemprop="url">
                  查看代码行数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T15:20:27+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/others/" itemprop="url" rel="index">
                    <span itemprop="name">others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>查看代码的行数 </p>
<ul>
<li><p><em>终端进入项目</em></p>
<p>打开终端,在终端 </p>
<p>$ cd + 项目文件</p>
</li>
<li><p><em>输入命令</em></p>
</li>
</ul>
<p> $ find . -name “*.swift” | xargs wc -l</p>
<p> 其中 “*.swift” 检查以.swift的文件，这样会显示出swift的文件的代码行数</p>
<p> 同理在OC中可以 “*.h”或者”.m”文件</p>
<ul>
<li><p>OC中可以一次性检查  多种文件如下抒写</p>
<p>$ find . “(“ -name “<em>.m” -or -name “</em>.mm” -or -name “<em>.cpp” -or -name “</em>.h” -or -name “*.rss” “)” -print | xargs wc -l</p>
</li>
</ul>
<ul>
<li><p>代码行数就会显示在终端</p>
<p><img src="/2017/06/20/查看代码行数/100.png" alt=""></p>
<hr>
<p><img src="/2017/06/20/查看代码行数/200.png" alt=""></p>
<hr>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://on55qmgxp.bkt.clouddn.com/avatar.png"
               alt="小毛纯一郎" />
          <p class="site-author-name" itemprop="name">小毛纯一郎</p>
           
              <p class="site-description motion-element" itemprop="description">致力于苹果移动应用的开发</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/MaoJianxiang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/mjx342112780" title="毛建祥" target="_blank">毛建祥</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://cepheussun.com" title="CepheusSun" target="_blank">CepheusSun</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小毛纯一郎</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">本站访客数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人次</span>
  

  
    <span class="site-pv">本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
  
  
</div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
